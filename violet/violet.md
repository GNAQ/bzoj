# 2708: [Violet 1]木偶

## 题解：

   我们我考虑一个可行的匹配方案。。假设我们已经确定了哪些木偶和提线是留下的，那么我们的匹配方式一定是排序之后按照顺序一一匹配。。换句话说不会出现交叉的提线。。原因是那样的话我们交换之后一定依然可行。。。

​    如果没有交叉。。那么可以想到如果一段是这样的向右倾斜的。。

 ![violet1](/Users/whx/Desktop/bzoj/violet1.png)



那么如果后边改向左倾斜。。交界点一定是这样的。。

 ![violet2](/Users/whx/Desktop/bzoj/violet2.png)

我们可以从绿色点把它断开断为一段一段的。。然后来分别做匹配。。

这样我们就可以dp啦f_i = f_j + [i~j段贡献]

假设一段要丢弃k个。。那么丢弃的一定是最靠边界的k个。。（在这个图的两边分别对应着最大的k个和最小的k个），原因很简单。。

1.对内：贪心地把未匹配的木偶和提线隔得越远越好

2.对外：相邻的两块一段向右倾斜，另一段就向右倾斜，我们发现这样不仅块内答案不变（木偶和提线的对称性），而且可以保证只要块内不能匹配了就不会出现跨块匹配的情况

所以[i~j]段贡献直接枚举丢多少个check一发就行了

# 2718: [Violet 4]毕业旅行

复习了一发数学知识

偏序集定义：

> 反链：最长两两不可比较的链，也就是选一些DAG的点，使得任意两点间没有边。


> 非严格偏序，自反偏序
> 
> 给定集合S，“≤”是S上的二元关系，若“≤”满足：
> 
> 自反性：∀a∈S，有a≤a；
> 
> 反对称性：∀a，b∈S，a≤b且b≤a，则a=b；
> 
> 传递性：∀a，b，c∈S，a≤b且b≤c，则a≤c；
> 
> 则称“≤”是S上的非严格偏序或自反偏序。


> 严格偏序，反自反偏序
> 
> 给定集合S，“＜”是S上的二元关系，若“＜”满足：
> 
> 反自反性：∀a∈S，有a≮a；
> 
> 非对称性：∀a，b∈S，a＜b ⇒ b≮a；
> 
> 传递性：∀a，b，c∈S，a＜b且b＜c，则a＜c；
> 
> 则称“＜”是S上的严格偏序或反自反偏序。
> 
> 严格偏序与有向无环图（dag）有直接的对应关系。一个集合上的严格偏序的关系图就是一个有向无环图。其传递闭包是它自己。

这里说的很清楚了。。DAG的edge(u,v)可以看做u>v。。。

所以DAG是一个偏序集，而这个偏序集中两元素可以比较的条件是通过传递性，一条不等式链把它们连接起来。。也就是从u可以到达v或者从v可以到达u

现在就是让你找最多的点让他们两两不能比较，这个在偏序集上叫做最长反链划分。。

然后根据Dilworth定理：

> 定理1 令（X,≤）是一个有限偏序集，并令r是其最大链的大小。则X可以被划分成r个但不能再少的反链。 
> 
> 其对偶定理称为Dilworth定理：
> 
> 定理2 令（X,≤）是一个有限偏序集，并令m是反链的最大的大小。则X可以被划分成m个但不能再少的链。

也就是

1.最长链 长度 等于 最小 反链划分。。

2.最长反链 长度 等于 最小 链划分。。

> 总结一下就是最长x链长度等于最小y链划分
> 
> 重点是区分出前者是一个链最长，后者是若干条链划分

有时间可以学习一下：http://blog.csdn.net/xiaohuan1991/article/details/6956629

于是这里的DAG显然是一个偏序集，两两不能互相到达显然是最长反链长度，那么我们的做法就是变成最小链划分做。。。

最小链划分在这里对应着最小路径覆盖，只要拆点之后每个点匹配一个next即可。。。那就变成了二分图匹配了。。答案就是n-maxflow

注意这里可比较对不止给出的m对，还有他们衍生出的那些可比较对。。都要floyd处理出来（就像置换群里面要包含所有的置换一样。。），然后再跑最小路径覆盖。。。（原因是这里是最小链划分而不是最小反链覆盖！）

# 2712: [Violet 2]棒球

简单的转化后问题就变成了求大小在两个分数之间的分母最小的分数。。

这是个经典的类欧几里得算法问题。。在杨哲的《一类分数问题的研究》和金斌的《欧几里得算法的应用》中都有提到。。

不幸的是。。他们都没有细讲实现。。比如递归的边界什么的。。

先看看原理吧..

我们的问题是求

$$
min\{(q,p)| \frac{a}{b}<\frac{p}{q}<\frac{c}{d}\}
$$

然后这么以来有三个性质：

1.

当存在正整数k，使得

$$

\frac{a}{b}<\frac{c}{d}

a > =b

t = \left\lfloor\frac{a}{b}\right\rfloor

a -= b * t \\c-=d*t

a - b * t = a \bmod b

\frac{a}{b}<\frac{p}{q} ===>p>\frac{a}{b}*q

\frac{d}{c}<\frac{q}{p}<\frac{b}{a}

0<\frac{p}{q}<\frac{c}{d}

q>\frac{p*d}{c}=\frac{d}{c}

q = \left\lfloor\frac{d}{c}\right\rfloor+1

$$

时。。p=k, q = 1

2.

当不存在正整数k时

$$
\left\lfloor\frac{a}{b}\right\rfloor=\left\lceil\frac{c}{d}\right\rceil \\or\\ \left\lfloor\frac{a}{b}\right\rfloor+1=\left\lceil\frac{c}{d}\right\rceil
$$

对于case1：

​	因为

$$
\frac{a}{b}<\frac{c}{d}
$$

​	所以不会出现

对于case2:

   如果

$$
a > =b
$$

   令

$$
t = \left\lfloor\frac{a}{b}\right\rfloor
$$

然后

$$
a -= b * t \\c-=d*t
$$

相当于向左平移了t，平移到了[0,1]中。。

注意这里

$$
a - b * t = a \bmod b
$$

这是让a对b取mod

3.考虑在[0,1]中怎么做

$$
\frac{a}{b}<\frac{p}{q} ===>p>\frac{a}{b}*q
$$

也就是说在q取得最小值时，p才能取得最小值。。

也就是min{(p,q)}和min{(q,p)}其实是一样的。。

那么我们可以考虑取倒数转化到前面的问题

$$
\frac{d}{c}<\frac{q}{p}<\frac{b}{a}
$$

*这一步的作用是交换了a和b*

一点小问题是a=0的情况。。

这个时候我们就是找



$$
0<\frac{p}{q}<\frac{c}{d}
$$

之前证明的q取得最小值时p也取得最小值。。这里显然p=1最小。。。

所以

$$
q>\frac{p*d}{c}=\frac{d}{c}
$$



$$
q = \left\lfloor\frac{d}{c}\right\rfloor+1
$$

结合这三个性质我们就可以交换a和b 、取mod了。。这样就可以辗转相除了。。。

实现就这么写咯：

``` c++
void solve(LL a, LL b, LL c, LL d){
	if ((a / b + 1) * d < c) x = a / b + 1, y = 1;
	else if (a >= b){
   		LL t = a / b;
    	solve(a - b * t, b, c - d * t, d);
    	x += y * t;
	}else{
    	if (a == 0) y = 1, x = d / c + 1;
    	else solve(d, c, b, a);
    	swap(x, y);
	}
}
```

读入的时候不能用double。。要用long long。。

被精度问题坑了好久。。。

## 小小的总结

辗转相除类问题的解题方法：

1.考虑有无两个量a，b在a>=b时可以转化为a<b的问题（取mod）

2.考虑这两个量在a<b时能否交换。。

# 2714: [Violet 3]交替和

## 题解

这题主要的难点在于这个和是正负交替的。。

我们不妨考虑如何倍增。。从i位b进制到i+1位

由于我们要在最高位上添加非0数，所以序列需要补0保证位数一样。。

比如

| 0    | 1    | 2    | 3    |
| :--- | ---- | ---- | ---- |
| 00   | 01   | 10   | 11   |

到

| 0    | 000  |
| ---- | ---- |
| 1    | 001  |
| 2    | 010  |
| 3    | 011  |
| 4    | 100  |
| 5    | 101  |
| 6    | 110  |
| 7    | 111  |

我们给每个数字标上正负，然后观察发现如果不考虑最高位上添的数，从2位到3位的时候。。i&1==0的数正负取反。。i&1==1的正负不变

原因是i&1==0的那些数前面加了奇数个最高位

i&1==1的那些数前面加了偶数个最高位。。。

所以我们按照i&1分类。。然后对最高位统计一下答案。。。

然后按照数位dp的办法统计下答案即可

这题主要的办法是把数位正负化为整个数字的正负。。。

然后若干情况讨论讨论咯。。我发现数位dp统计000jxxx和nnnjxxx分开写可能更好写

# 2721: [Violet 5]樱花

$$
\frac{1}{x}+\frac{1}{y}=\frac{1}{n!}\\\frac{x+y}{xy}=\frac{1}{n!}\\(x+y)n!=xy
$$

考虑到我们的目标是统计数对(x,y)的个数，而这里是x和y的数量关系，我们可以用x表示出y，然后找出x的取值范围

$$
y=\frac{n!x}{x-n!}=n+\frac{n!^2}{x-n!}=n+\frac{n!^2}{t}
$$

那么也就是说。。x的取值是n!+t 然后 t | (n!)^2

每个t对应一个x，每个x对应一个y

那么答案就是n!的约数个数

# 2713: [Violet 2]愚蠢的副官

又见数位dp。。这个数据范围肯定是数位dp，但是我们其实不好dp。。因为我们dp的时候贡献没法按位拆分。。那样就要把这个数压到状态里，而这是不可接受的。。

然后我们仔细观察这个f(n)

它的两个部分：n、n的各位数字之积。。

前者的范围是1~10^18全体，这是没法改变的。。

后者的范围似乎也是1~10^18？然而后者并没有取满这个范围，因为首先不能有0参与，其次只是1~9以内的数字可以造成的乘积。。

这个特殊型如何利用呢。。。？注意乘积的基本单位是质因数，1~9以内只有2、3、5、7这4个质因数。。

那么我们直接枚举出每个质因数有多少个，注意一旦当前的这些 质因数^个数 的积超过了n就break到上一层循环，跑了边程序发现只有66061种质因数组合。。

我们枚举这个组合，就去掉了f(n)中后面的一半，然后前面一半就是找一些数字使得它们的乘积恰为这些质因数，然后数字本身大小不能超过n，这是一个经典的数位dp，分析复杂度的时候注意i位的分别有a1 a2 a3 a4个质数的数个数 这个是可以预处理的，然后我们每次统计答案的时候只枚举位数和这位是什么，然后调用那个预处理的答案，统计答案是

O(10^2  m)的。。

这是很重要的。。需要较为深入的理解数位dp是怎么进行的。。dp和统计是可以分开的。。尤其是在多次统计的时候

# 2711: [Violet 2]After 17

考虑到向量点积性质1：分配律

$$
\sum_i\sum_{j!=i}a_ia_j
\\=\sum_i a_i * ( \sum_j a_j - a_i)
\\=(\sum_i a_i)^2-\sum_i a_i^2
$$

然后有一个重要的性质是每个ai一定取在x y边界的四个点上。。

这类性质在这种题目里很常见。。。证明如下：

我们不妨不考虑和ai无关的ai aj 只考虑和ai相关的。。。

那么这样的话假设其他aj的和为sum，我们现在的目标就是最大化ai * sum

点积的性质2：两维度独立(a_x * b_x + a_y * b_y)

如果sum_x>0那么a_x一定-x最优，如果sum_x<0那么a_x一定是x最优。。

y也一样。。所以一定在边界上。。

那么

$$
\sum_i a_i^2
$$

是个定值。。

现在就是让前面的最小。。。我们还是把x轴和y轴拆开看。。。

最小化(x1+x2+...xn)^2 + (y1+y2+…+yn)^2

我们决策下每次选x还是-x，最后最小化abs(x1+x2+...xn)

这可以使用简单的背包实现。。

这就解决了本题。。主要难点在于那些性质1、性质2的应用。。找到两维独立。。以及贪心性质的发掘。。

教训是多想想点积性质，这类题目多找找维度之间是否独立，有无关系，以及试试是不是都取在边界上。。。

# 2715: [Violet 3]最优指令

我们只在乎那些状态上有点，而不在乎有多少个，压成一个二进制跑bfs即可。。

# 2720: [Violet 5]列队春游

n^3暴力都能过。。乱搞搞即可