# bzoj 4180

我们考虑对每个S考虑操作次数如何最少

由于一个T的子串的后缀也是T的子串

可以贪心的读入S的每个字符，在SAM上走。。如果trans[x] != NULL就不划分，如果trans[x]==NULL就划分一下然后o = S->trans[x]如果S->trans[x]为空就o=S

我们建出T的这么一棵SAM之后考虑怎么做能让这玩意最大。。

由于SAM是DAG，所以要走到S->trans[x]的那些点只可能是这样。。

也就是想办法经过那些边尽可能多次。。

然而并没有什么很好的做法。。？

我们应该注意到：从S或者S->trans[x]往下走—-->走到一个点无法转移——>回到S或者S->trans[x]

这个过程有明显的阶段和重复。。。

也就是说。。如果我第一个字母x（从哪走）确定了。。我最后一个字母y（走到哪）确定了。。这个路径一定取一个最短的。。

这样就可以只保留5个点。。建一个图出来了。。边长度范围10^5

然后要求这个图中从S开始走，走的总长为n，最多能经过多少点。。

注意这个路径长度太长不好处理。。二份答案转为判定问题（同时的效果是最大—>最小）

转化为：经过xx个点的时候，最短是多长？

 f_i,j,k表示经过2^i个点，从j走到k的最短是多长。。然后倍增一下即可。。

这样就解决了本题。。

# 一个坑

怎么处理出从每个字母走到另外一个字母的权值呢。。？

显然是trans边是吧。。？但是你要注意在后缀树上很多个节点缩在一起的时候。。。你就不能只考虑那些没有被缩起来的点了。。

直接后缀树做应该也行？还是在SAM上试一试咯？

注意我们的目标是*最小化*以x开头y结尾的除了结尾字符之外都是子串，自己却不是的字符串长度。。（最小化因为这等于是答案加1的花费）

我们处理出从SAM上每个字符走到每个节点的最短长度，这个按照T[i].l排序后dp（T[i].par->l < T[i].l）即可

然后枚举每个trans[c]==0的(node, c)统计答案即可