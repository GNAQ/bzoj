ZJOI 2015 day1 幻想乡战略游戏题解：
	首先我们考虑重心的性质，也就是它的每个子树内的带权和都小于等于总权和的1/2，所以我们可以使用调整法求重心，每次哪个子树的带权和最大我们就往哪走。。。直到不存在大于总权和1/2的子树。。

	然而这么做是O(n)的，由于我们是每次走到一个子树中，然后每次再找下一步，显然走过来的那个点的其它子树都不可能再被访问到了，相当于把一个树从一个点裂成若干子树，然后递归进一个子树，这和点分治的过程差不多，我们就可以像点分治一样，每次取重心断开、访问进一个，复杂度O(logn)

	然而我们怎么维护每个子树的权和以及重心的ans呢。。？链剖吗。。？我们还是应该充分利用我们的点分治的结构，这个结构上，每个点只在logn个重心的『子树』中，好处是：
		1.修改一个点的时候只要往上跳log次，把这log个重心上存的关于这个点的信息全部修改即可。
		2.在查询所有点到一个点的信息的时候（比如带权重心），只要信息满足区间加法（可以在lca处合并），那么就可以在点分治的重心处合并，然后只要往上跳log次，每次统计出别的子树到这个分治重心再到询问节点的贡献即可。

	在这道题中，我们就需要在每个点维护这些信息：
		每个点分治的下一层孩子ch，
		上层的重心par,
		在点分治中的层号dep，
		点分治中每个子树（分别和总共都要维护下）中所有点到它的带权距离a1，
		所有子树的权和sum，

	由于需要从根往下找重心，这道题还有一个trick,就是我们从root往下走的时候，如果从x，走到了v子树的重心，那么需要把x直接缩到v这个点上（所以才需要维护a1）

	这种点分树的另外一个理解办法是：
	我们平常在lca处dfs所有子树并合并答案是O(n^2)的，但是如果点分治就降低了这样的层数，变成了O(nlogn)
	这里就是我们暴力在每个点处维护每个子树的信息，然后修改/查询点的时候顺着father边一层层往上跳是O(nq)的，但是我们现在点分治把层数降到了log，那么就变成了O(qlogn)
	所以这种做法非常适合维护『点对』，或者是所有点到一个点的信息
